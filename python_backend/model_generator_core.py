"""
3D Model Generation Core - Extract trees from JSON and generate OBJ file
Extracted from json_to_3d_model.py without GUI dependencies
"""

import os
from typing import Dict, List, Any, Tuple
from datetime import datetime


def load_tree_model(model_path: str = "tree_model/Henkel_tree.obj") -> Tuple[List, List, List]:
    """
    Load the base tree model from OBJ file.
    
    Args:
        model_path: Path to the base tree OBJ file
    
    Returns:
        Tuple of (vertices, faces, normals)
    """
    if not os.path.exists(model_path):
        raise FileNotFoundError(f"Tree model not found: {model_path}")
    
    vertices = []
    faces = []
    normals = []
    
    with open(model_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('v '):
                # Vertex
                parts = line.split()
                vertices.append([float(parts[1]), float(parts[2]), float(parts[3])])
            elif line.startswith('vn '):
                # Normal
                parts = line.split()
                normals.append([float(parts[1]), float(parts[2]), float(parts[3])])
            elif line.startswith('f '):
                # Face
                parts = line.split()[1:]
                face = []
                for part in parts:
                    # Handle format: v/vt/vn or v//vn or v
                    indices = part.split('/')
                    face.append(int(indices[0]))
                faces.append(face)
    
    return vertices, faces, normals


def extract_trees_from_detection(detection_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Extract all tree positions from detection result.
    
    Args:
        detection_data: Tree detection JSON from FastAPI endpoint
    
    Returns:
        List of trees with x, y, diameter
    """
    all_trees = []
    
    # Individual trees
    for tree in detection_data.get('individualTrees', []):
        all_trees.append({
            'x': tree['centroidM'][0],
            'y': tree['centroidM'][1],
            'diameter': tree['estimatedDiameterM']
        })
    
    # Trees in clusters
    for cluster in detection_data.get('treeClusters', []):
        for tree in cluster.get('populatedTrees', []):
            all_trees.append({
                'x': tree['positionM'][0],
                'y': tree['positionM'][1],
                'diameter': tree['estimatedDiameterM']
            })
    
    return all_trees


def generate_obj_content(
    detection_data: Dict[str, Any],
    base_tree_height: float = 5.0,
    model_path: str = "tree_model/Henkel_tree.obj"
) -> Tuple[str, str]:
    """
    Generate OBJ and MTL file contents from detection data.
    
    Args:
        detection_data: Tree detection JSON
        base_tree_height: Height of the base tree model in meters
        model_path: Path to base tree model
    
    Returns:
        Tuple of (obj_content, mtl_content)
    """
    # Load base tree model
    tree_vertices, tree_faces, tree_normals = load_tree_model(model_path)
    
    # Extract metadata
    metadata = detection_data.get('metadata', {})
    real_dims = metadata.get('realDimensionsM', {})
    tile_width = real_dims.get('width', 0)
    tile_height = real_dims.get('height', 0)
    
    # Extract all trees
    trees = extract_trees_from_detection(detection_data)
    
    # Calculate tile center for origin offset
    tile_center_x = tile_width / 2
    tile_center_z = tile_height / 2
    
    # Generate OBJ content
    obj_lines = []
    obj_lines.append("# Generated by Forma Tree Detection")
    obj_lines.append(f"# Generated: {datetime.now().isoformat()}")
    obj_lines.append(f"# Trees: {len(trees)}")
    obj_lines.append(f"# Tile size: {tile_width:.2f}m × {tile_height:.2f}m")
    obj_lines.append(f"# Origin: Center of tile ({tile_center_x:.2f}, {tile_center_z:.2f})")
    obj_lines.append("mtllib trees_model.mtl\n")
    
    vertex_offset = 1  # OBJ indices start at 1
    
    # === Trees ===
    obj_lines.append("# Trees")
    obj_lines.append("usemtl tree_material\n")
    
    for i, tree in enumerate(trees):
        # Calculate tree height and scale
        tree_height = tree['diameter'] * 1.5  # Linear relationship
        scale_factor = tree_height / base_tree_height
        
        obj_lines.append(f"# Tree {i+1} (diameter: {tree['diameter']:.1f}m, height: {tree_height:.1f}m)")
        obj_lines.append(f"o Tree_{i+1}")
        
        # Write transformed vertices
        # Apply 90° rotation around X-axis to make Y the vertical axis
        # Original model: Z is up (0 to ~1.4m)
        # After rotation: Y is up
        # Center the model at tile center for Forma ref point alignment
        for vertex in tree_vertices:
            # Scale the base vertex
            scaled_x = vertex[0] * scale_factor
            scaled_y = vertex[1] * scale_factor
            scaled_z = vertex[2] * scale_factor
            
            # Rotate 90° around X-axis: (x, y, z) -> (x, z, y)
            # This makes what was Z (up) become Y (up in Forma)
            rotated_x = scaled_x
            rotated_y = scaled_z  # What was Z becomes Y (vertical)
            rotated_z = scaled_y  # What was Y becomes Z
            
            # Translate to tree position, centered at tile center
            # No Y-flip needed since rotation already handled orientation
            x = rotated_x + (tree['x'] - tile_center_x)
            y = rotated_y  # Height above ground (what was Z)
            z = rotated_z + ( tile_center_z - tree['y'])  # Direct position, no flip
            
            obj_lines.append(f"v {x} {y} {z}")
        
        # Write faces (adjust indices)
        for face in tree_faces:
            face_str = " ".join([str(idx + vertex_offset - 1) for idx in face])
            obj_lines.append(f"f {face_str}")
        
        vertex_offset += len(tree_vertices)
        obj_lines.append("")
    
    # Generate MTL content
    mtl_lines = []
    mtl_lines.append("# Material file generated by Forma Tree Detection\n")
    
    # Tree material (simple green)
    mtl_lines.append("newmtl tree_material")
    mtl_lines.append("Ka 0.2 0.5 0.2")  # Ambient color (green)
    mtl_lines.append("Kd 0.3 0.7 0.3")  # Diffuse color (green)
    mtl_lines.append("Ks 0.1 0.1 0.1")  # Specular color (slight shine)
    
    obj_content = "\n".join(obj_lines)
    mtl_content = "\n".join(mtl_lines)
    
    return obj_content, mtl_content


def generate_model_metadata(detection_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Generate metadata about the 3D model.
    
    Args:
        detection_data: Tree detection JSON
    
    Returns:
        Metadata dict with model statistics
    """
    trees = extract_trees_from_detection(detection_data)
    
    # Load base model to count vertices/faces
    try:
        tree_vertices, tree_faces, _ = load_tree_model()
        vertices_per_tree = len(tree_vertices)
        faces_per_tree = len(tree_faces)
    except:
        vertices_per_tree = 0
        faces_per_tree = 0
    
    # Calculate totals (ground plane + trees)
    total_vertices = 4 + (vertices_per_tree * len(trees))  # 4 for ground
    total_faces = 2 + (faces_per_tree * len(trees))  # 2 for ground
    
    metadata = detection_data.get('metadata', {})
    real_dims = metadata.get('realDimensionsM', {})
    
    return {
        "totalTrees": len(trees),
        "totalVertices": total_vertices,
        "totalFaces": total_faces,
        "tileWidth": real_dims.get('width', 0),
        "tileHeight": real_dims.get('height', 0),
        "timestamp": datetime.now().isoformat()
    }
